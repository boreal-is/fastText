// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WordVector.proto

#ifndef PROTOBUF_WordVector_2eproto__INCLUDED
#define PROTOBUF_WordVector_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_WordVector_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsDetectLanguagesRequestImpl();
void InitDefaultsDetectLanguagesRequest();
void InitDefaultsDetectLanguagesReplyImpl();
void InitDefaultsDetectLanguagesReply();
void InitDefaultsGetVectorsRequestImpl();
void InitDefaultsGetVectorsRequest();
void InitDefaultsGetVectorsReplyImpl();
void InitDefaultsGetVectorsReply();
void InitDefaultsDetectedLanguageImpl();
void InitDefaultsDetectedLanguage();
void InitDefaultsVectorImpl();
void InitDefaultsVector();
inline void InitDefaults() {
  InitDefaultsDetectLanguagesRequest();
  InitDefaultsDetectLanguagesReply();
  InitDefaultsGetVectorsRequest();
  InitDefaultsGetVectorsReply();
  InitDefaultsDetectedLanguage();
  InitDefaultsVector();
}
}  // namespace protobuf_WordVector_2eproto
namespace WordVector {
class DetectLanguagesReply;
class DetectLanguagesReplyDefaultTypeInternal;
extern DetectLanguagesReplyDefaultTypeInternal _DetectLanguagesReply_default_instance_;
class DetectLanguagesRequest;
class DetectLanguagesRequestDefaultTypeInternal;
extern DetectLanguagesRequestDefaultTypeInternal _DetectLanguagesRequest_default_instance_;
class DetectedLanguage;
class DetectedLanguageDefaultTypeInternal;
extern DetectedLanguageDefaultTypeInternal _DetectedLanguage_default_instance_;
class GetVectorsReply;
class GetVectorsReplyDefaultTypeInternal;
extern GetVectorsReplyDefaultTypeInternal _GetVectorsReply_default_instance_;
class GetVectorsRequest;
class GetVectorsRequestDefaultTypeInternal;
extern GetVectorsRequestDefaultTypeInternal _GetVectorsRequest_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace WordVector
namespace WordVector {

// ===================================================================

class DetectLanguagesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.DetectLanguagesRequest) */ {
 public:
  DetectLanguagesRequest();
  virtual ~DetectLanguagesRequest();

  DetectLanguagesRequest(const DetectLanguagesRequest& from);

  inline DetectLanguagesRequest& operator=(const DetectLanguagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectLanguagesRequest(DetectLanguagesRequest&& from) noexcept
    : DetectLanguagesRequest() {
    *this = ::std::move(from);
  }

  inline DetectLanguagesRequest& operator=(DetectLanguagesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectLanguagesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectLanguagesRequest* internal_default_instance() {
    return reinterpret_cast<const DetectLanguagesRequest*>(
               &_DetectLanguagesRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(DetectLanguagesRequest* other);
  friend void swap(DetectLanguagesRequest& a, DetectLanguagesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectLanguagesRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DetectLanguagesRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetectLanguagesRequest& from);
  void MergeFrom(const DetectLanguagesRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetectLanguagesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string texts = 1;
  int texts_size() const;
  void clear_texts();
  static const int kTextsFieldNumber = 1;
  const ::std::string& texts(int index) const;
  ::std::string* mutable_texts(int index);
  void set_texts(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_texts(int index, ::std::string&& value);
  #endif
  void set_texts(int index, const char* value);
  void set_texts(int index, const char* value, size_t size);
  ::std::string* add_texts();
  void add_texts(const ::std::string& value);
  #if LANG_CXX11
  void add_texts(::std::string&& value);
  #endif
  void add_texts(const char* value);
  void add_texts(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& texts() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_texts();

  // @@protoc_insertion_point(class_scope:WordVector.DetectLanguagesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> texts_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsDetectLanguagesRequestImpl();
};
// -------------------------------------------------------------------

class DetectLanguagesReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.DetectLanguagesReply) */ {
 public:
  DetectLanguagesReply();
  virtual ~DetectLanguagesReply();

  DetectLanguagesReply(const DetectLanguagesReply& from);

  inline DetectLanguagesReply& operator=(const DetectLanguagesReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectLanguagesReply(DetectLanguagesReply&& from) noexcept
    : DetectLanguagesReply() {
    *this = ::std::move(from);
  }

  inline DetectLanguagesReply& operator=(DetectLanguagesReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectLanguagesReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectLanguagesReply* internal_default_instance() {
    return reinterpret_cast<const DetectLanguagesReply*>(
               &_DetectLanguagesReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(DetectLanguagesReply* other);
  friend void swap(DetectLanguagesReply& a, DetectLanguagesReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectLanguagesReply* New() const PROTOBUF_FINAL { return New(NULL); }

  DetectLanguagesReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetectLanguagesReply& from);
  void MergeFrom(const DetectLanguagesReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetectLanguagesReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .WordVector.DetectedLanguage results = 1;
  int results_size() const;
  void clear_results();
  static const int kResultsFieldNumber = 1;
  const ::WordVector::DetectedLanguage& results(int index) const;
  ::WordVector::DetectedLanguage* mutable_results(int index);
  ::WordVector::DetectedLanguage* add_results();
  ::google::protobuf::RepeatedPtrField< ::WordVector::DetectedLanguage >*
      mutable_results();
  const ::google::protobuf::RepeatedPtrField< ::WordVector::DetectedLanguage >&
      results() const;

  // @@protoc_insertion_point(class_scope:WordVector.DetectLanguagesReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::WordVector::DetectedLanguage > results_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsDetectLanguagesReplyImpl();
};
// -------------------------------------------------------------------

class GetVectorsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.GetVectorsRequest) */ {
 public:
  GetVectorsRequest();
  virtual ~GetVectorsRequest();

  GetVectorsRequest(const GetVectorsRequest& from);

  inline GetVectorsRequest& operator=(const GetVectorsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVectorsRequest(GetVectorsRequest&& from) noexcept
    : GetVectorsRequest() {
    *this = ::std::move(from);
  }

  inline GetVectorsRequest& operator=(GetVectorsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVectorsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVectorsRequest* internal_default_instance() {
    return reinterpret_cast<const GetVectorsRequest*>(
               &_GetVectorsRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(GetVectorsRequest* other);
  friend void swap(GetVectorsRequest& a, GetVectorsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVectorsRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetVectorsRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetVectorsRequest& from);
  void MergeFrom(const GetVectorsRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetVectorsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tokens = 1;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 1;
  const ::std::string& tokens(int index) const;
  ::std::string* mutable_tokens(int index);
  void set_tokens(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tokens(int index, ::std::string&& value);
  #endif
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  ::std::string* add_tokens();
  void add_tokens(const ::std::string& value);
  #if LANG_CXX11
  void add_tokens(::std::string&& value);
  #endif
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tokens() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tokens();

  // @@protoc_insertion_point(class_scope:WordVector.GetVectorsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tokens_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsGetVectorsRequestImpl();
};
// -------------------------------------------------------------------

class GetVectorsReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.GetVectorsReply) */ {
 public:
  GetVectorsReply();
  virtual ~GetVectorsReply();

  GetVectorsReply(const GetVectorsReply& from);

  inline GetVectorsReply& operator=(const GetVectorsReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVectorsReply(GetVectorsReply&& from) noexcept
    : GetVectorsReply() {
    *this = ::std::move(from);
  }

  inline GetVectorsReply& operator=(GetVectorsReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVectorsReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVectorsReply* internal_default_instance() {
    return reinterpret_cast<const GetVectorsReply*>(
               &_GetVectorsReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetVectorsReply* other);
  friend void swap(GetVectorsReply& a, GetVectorsReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVectorsReply* New() const PROTOBUF_FINAL { return New(NULL); }

  GetVectorsReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetVectorsReply& from);
  void MergeFrom(const GetVectorsReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetVectorsReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .WordVector.Vector vectors = 1;
  int vectors_size() const;
  void clear_vectors();
  static const int kVectorsFieldNumber = 1;
  const ::WordVector::Vector& vectors(int index) const;
  ::WordVector::Vector* mutable_vectors(int index);
  ::WordVector::Vector* add_vectors();
  ::google::protobuf::RepeatedPtrField< ::WordVector::Vector >*
      mutable_vectors();
  const ::google::protobuf::RepeatedPtrField< ::WordVector::Vector >&
      vectors() const;

  // @@protoc_insertion_point(class_scope:WordVector.GetVectorsReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::WordVector::Vector > vectors_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsGetVectorsReplyImpl();
};
// -------------------------------------------------------------------

class DetectedLanguage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.DetectedLanguage) */ {
 public:
  DetectedLanguage();
  virtual ~DetectedLanguage();

  DetectedLanguage(const DetectedLanguage& from);

  inline DetectedLanguage& operator=(const DetectedLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DetectedLanguage(DetectedLanguage&& from) noexcept
    : DetectedLanguage() {
    *this = ::std::move(from);
  }

  inline DetectedLanguage& operator=(DetectedLanguage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DetectedLanguage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DetectedLanguage* internal_default_instance() {
    return reinterpret_cast<const DetectedLanguage*>(
               &_DetectedLanguage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DetectedLanguage* other);
  friend void swap(DetectedLanguage& a, DetectedLanguage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DetectedLanguage* New() const PROTOBUF_FINAL { return New(NULL); }

  DetectedLanguage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DetectedLanguage& from);
  void MergeFrom(const DetectedLanguage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DetectedLanguage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:WordVector.DetectedLanguage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsDetectedLanguageImpl();
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:WordVector.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Vector* other);
  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const PROTOBUF_FINAL { return New(NULL); }

  Vector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // float frequency = 1;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 1;
  float frequency() const;
  void set_frequency(float value);

  // @@protoc_insertion_point(class_scope:WordVector.Vector)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  float frequency_;
  mutable int _cached_size_;
  friend struct ::protobuf_WordVector_2eproto::TableStruct;
  friend void ::protobuf_WordVector_2eproto::InitDefaultsVectorImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DetectLanguagesRequest

// repeated string texts = 1;
inline int DetectLanguagesRequest::texts_size() const {
  return texts_.size();
}
inline void DetectLanguagesRequest::clear_texts() {
  texts_.Clear();
}
inline const ::std::string& DetectLanguagesRequest::texts(int index) const {
  // @@protoc_insertion_point(field_get:WordVector.DetectLanguagesRequest.texts)
  return texts_.Get(index);
}
inline ::std::string* DetectLanguagesRequest::mutable_texts(int index) {
  // @@protoc_insertion_point(field_mutable:WordVector.DetectLanguagesRequest.texts)
  return texts_.Mutable(index);
}
inline void DetectLanguagesRequest::set_texts(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:WordVector.DetectLanguagesRequest.texts)
  texts_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DetectLanguagesRequest::set_texts(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:WordVector.DetectLanguagesRequest.texts)
  texts_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DetectLanguagesRequest::set_texts(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  texts_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:WordVector.DetectLanguagesRequest.texts)
}
inline void DetectLanguagesRequest::set_texts(int index, const char* value, size_t size) {
  texts_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WordVector.DetectLanguagesRequest.texts)
}
inline ::std::string* DetectLanguagesRequest::add_texts() {
  // @@protoc_insertion_point(field_add_mutable:WordVector.DetectLanguagesRequest.texts)
  return texts_.Add();
}
inline void DetectLanguagesRequest::add_texts(const ::std::string& value) {
  texts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:WordVector.DetectLanguagesRequest.texts)
}
#if LANG_CXX11
inline void DetectLanguagesRequest::add_texts(::std::string&& value) {
  texts_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:WordVector.DetectLanguagesRequest.texts)
}
#endif
inline void DetectLanguagesRequest::add_texts(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  texts_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:WordVector.DetectLanguagesRequest.texts)
}
inline void DetectLanguagesRequest::add_texts(const char* value, size_t size) {
  texts_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:WordVector.DetectLanguagesRequest.texts)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DetectLanguagesRequest::texts() const {
  // @@protoc_insertion_point(field_list:WordVector.DetectLanguagesRequest.texts)
  return texts_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DetectLanguagesRequest::mutable_texts() {
  // @@protoc_insertion_point(field_mutable_list:WordVector.DetectLanguagesRequest.texts)
  return &texts_;
}

// -------------------------------------------------------------------

// DetectLanguagesReply

// repeated .WordVector.DetectedLanguage results = 1;
inline int DetectLanguagesReply::results_size() const {
  return results_.size();
}
inline void DetectLanguagesReply::clear_results() {
  results_.Clear();
}
inline const ::WordVector::DetectedLanguage& DetectLanguagesReply::results(int index) const {
  // @@protoc_insertion_point(field_get:WordVector.DetectLanguagesReply.results)
  return results_.Get(index);
}
inline ::WordVector::DetectedLanguage* DetectLanguagesReply::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:WordVector.DetectLanguagesReply.results)
  return results_.Mutable(index);
}
inline ::WordVector::DetectedLanguage* DetectLanguagesReply::add_results() {
  // @@protoc_insertion_point(field_add:WordVector.DetectLanguagesReply.results)
  return results_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::WordVector::DetectedLanguage >*
DetectLanguagesReply::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:WordVector.DetectLanguagesReply.results)
  return &results_;
}
inline const ::google::protobuf::RepeatedPtrField< ::WordVector::DetectedLanguage >&
DetectLanguagesReply::results() const {
  // @@protoc_insertion_point(field_list:WordVector.DetectLanguagesReply.results)
  return results_;
}

// -------------------------------------------------------------------

// GetVectorsRequest

// repeated string tokens = 1;
inline int GetVectorsRequest::tokens_size() const {
  return tokens_.size();
}
inline void GetVectorsRequest::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& GetVectorsRequest::tokens(int index) const {
  // @@protoc_insertion_point(field_get:WordVector.GetVectorsRequest.tokens)
  return tokens_.Get(index);
}
inline ::std::string* GetVectorsRequest::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:WordVector.GetVectorsRequest.tokens)
  return tokens_.Mutable(index);
}
inline void GetVectorsRequest::set_tokens(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:WordVector.GetVectorsRequest.tokens)
  tokens_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetVectorsRequest::set_tokens(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:WordVector.GetVectorsRequest.tokens)
  tokens_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetVectorsRequest::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:WordVector.GetVectorsRequest.tokens)
}
inline void GetVectorsRequest::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:WordVector.GetVectorsRequest.tokens)
}
inline ::std::string* GetVectorsRequest::add_tokens() {
  // @@protoc_insertion_point(field_add_mutable:WordVector.GetVectorsRequest.tokens)
  return tokens_.Add();
}
inline void GetVectorsRequest::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:WordVector.GetVectorsRequest.tokens)
}
#if LANG_CXX11
inline void GetVectorsRequest::add_tokens(::std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:WordVector.GetVectorsRequest.tokens)
}
#endif
inline void GetVectorsRequest::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:WordVector.GetVectorsRequest.tokens)
}
inline void GetVectorsRequest::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:WordVector.GetVectorsRequest.tokens)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetVectorsRequest::tokens() const {
  // @@protoc_insertion_point(field_list:WordVector.GetVectorsRequest.tokens)
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetVectorsRequest::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:WordVector.GetVectorsRequest.tokens)
  return &tokens_;
}

// -------------------------------------------------------------------

// GetVectorsReply

// repeated .WordVector.Vector vectors = 1;
inline int GetVectorsReply::vectors_size() const {
  return vectors_.size();
}
inline void GetVectorsReply::clear_vectors() {
  vectors_.Clear();
}
inline const ::WordVector::Vector& GetVectorsReply::vectors(int index) const {
  // @@protoc_insertion_point(field_get:WordVector.GetVectorsReply.vectors)
  return vectors_.Get(index);
}
inline ::WordVector::Vector* GetVectorsReply::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:WordVector.GetVectorsReply.vectors)
  return vectors_.Mutable(index);
}
inline ::WordVector::Vector* GetVectorsReply::add_vectors() {
  // @@protoc_insertion_point(field_add:WordVector.GetVectorsReply.vectors)
  return vectors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::WordVector::Vector >*
GetVectorsReply::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:WordVector.GetVectorsReply.vectors)
  return &vectors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::WordVector::Vector >&
GetVectorsReply::vectors() const {
  // @@protoc_insertion_point(field_list:WordVector.GetVectorsReply.vectors)
  return vectors_;
}

// -------------------------------------------------------------------

// DetectedLanguage

// string text = 1;
inline void DetectedLanguage::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DetectedLanguage::text() const {
  // @@protoc_insertion_point(field_get:WordVector.DetectedLanguage.text)
  return text_.GetNoArena();
}
inline void DetectedLanguage::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WordVector.DetectedLanguage.text)
}
#if LANG_CXX11
inline void DetectedLanguage::set_text(::std::string&& value) {
  
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WordVector.DetectedLanguage.text)
}
#endif
inline void DetectedLanguage::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WordVector.DetectedLanguage.text)
}
inline void DetectedLanguage::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WordVector.DetectedLanguage.text)
}
inline ::std::string* DetectedLanguage::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:WordVector.DetectedLanguage.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetectedLanguage::release_text() {
  // @@protoc_insertion_point(field_release:WordVector.DetectedLanguage.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetectedLanguage::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:WordVector.DetectedLanguage.text)
}

// string language = 2;
inline void DetectedLanguage::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DetectedLanguage::language() const {
  // @@protoc_insertion_point(field_get:WordVector.DetectedLanguage.language)
  return language_.GetNoArena();
}
inline void DetectedLanguage::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WordVector.DetectedLanguage.language)
}
#if LANG_CXX11
inline void DetectedLanguage::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WordVector.DetectedLanguage.language)
}
#endif
inline void DetectedLanguage::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WordVector.DetectedLanguage.language)
}
inline void DetectedLanguage::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WordVector.DetectedLanguage.language)
}
inline ::std::string* DetectedLanguage::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:WordVector.DetectedLanguage.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetectedLanguage::release_language() {
  // @@protoc_insertion_point(field_release:WordVector.DetectedLanguage.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetectedLanguage::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:WordVector.DetectedLanguage.language)
}

// -------------------------------------------------------------------

// Vector

// float frequency = 1;
inline void Vector::clear_frequency() {
  frequency_ = 0;
}
inline float Vector::frequency() const {
  // @@protoc_insertion_point(field_get:WordVector.Vector.frequency)
  return frequency_;
}
inline void Vector::set_frequency(float value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:WordVector.Vector.frequency)
}

// bytes data = 2;
inline void Vector::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Vector::data() const {
  // @@protoc_insertion_point(field_get:WordVector.Vector.data)
  return data_.GetNoArena();
}
inline void Vector::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:WordVector.Vector.data)
}
#if LANG_CXX11
inline void Vector::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:WordVector.Vector.data)
}
#endif
inline void Vector::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:WordVector.Vector.data)
}
inline void Vector::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:WordVector.Vector.data)
}
inline ::std::string* Vector::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:WordVector.Vector.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vector::release_data() {
  // @@protoc_insertion_point(field_release:WordVector.Vector.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vector::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:WordVector.Vector.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace WordVector

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_WordVector_2eproto__INCLUDED
